<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Interactive annotated security focused kubernetes diagram." />
    <meta name="author" content="Lars Solberg" />

    <link rel="icon" type="image/svg+xml"
        href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><rect width="64" height="64" fill="%23006ce0"/><circle cx="16" cy="16" r="4" fill="%23c00"/><circle cx="32" cy="16" r="4" fill="%23f60"/><circle cx="48" cy="16" r="4" fill="%23ff0"/><circle cx="16" cy="32" r="4" fill="%23ff0"/><circle cx="32" cy="32" r="4" fill="%23c00"/><circle cx="48" cy="32" r="4" fill="%23f60"/><circle cx="16" cy="48" r="4" fill="%23f60"/><circle cx="32" cy="48" r="4" fill="%23ff0"/><circle cx="48" cy="48" r="4" fill="%23c00"/></svg>'>

    <title>kubesec-diagram</title>
    <style>
        body {
            margin: 0;
            font-family: sans-serif;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        #image-wrapper {
            position: relative;
            flex-shrink: 0;
        }

        #main-image {
            height: 100vh;
            display: block;
        }

        #tooltip-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999;
            pointer-events: none;
        }

        .marker {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.8;
            z-index: 1;
            transform: translate(-50%, -50%);
            border: 2px solid;
        }

        .tooltip-box {
            position: absolute;
            background: rgba(30, 30, 30, 0.95);
            color: white;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            min-width: 320px;
            max-width: 500px;
            white-space: pre-wrap;
            text-align: left;
            pointer-events: auto;
            transform: translate(-50%, 0);
            display: none;
        }

        .tooltip-box a {
            color: #4fc3f7;
            text-decoration: underline;
        }

        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .controls button {
            background-color: #000c;
            color: #fff;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #annotation-list {
            flex: 1;
            height: 100vh;
            overflow-x: scroll;
            overflow-y: hidden;
            padding: 20px;
            column-width: 260px;
            column-gap: 32px;
            column-fill: auto;
        }

        .annotation-item {
            margin-bottom: 12px;
            font-size: 14px;
            padding: 8px;
            border-radius: 6px;
            break-inside: avoid;
        }

        .annotation-item:nth-child(even) {
            background: #f9f9f9;
        }

        .annotation-item:nth-child(odd) {
            background: #fff;
        }

        .annotation-separator {
            display: flex;
            align-items: center;
            margin: 24px 0 12px;
            font-weight: bold;
            color: #555;
            white-space: nowrap;
            break-inside: avoid;
        }

        .annotation-separator::before,
        .annotation-separator::after {
            content: "";
            flex: 1;
            border-top: 1px solid #ccc;
            margin: 0 8px;
        }

        .annotation-separator span {
            white-space: nowrap;
        }

        .hidden-markers .marker {
            display: none !important;
        }

        .numbered .marker::before {
            content: attr(data-index);
            position: relative;
            z-index: 1;
        }

        #main-image {
            height: 100vh;
            max-width: 100vw;
            width: auto;
            display: block;
        }

        body.annotations-active #main-image {
            max-width: calc(100vw - 500px);
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="image-wrapper">
            <div class="controls">
                <button id="toggle-annotations">Show Annotations</button>
                <button id="toggle-markers">Hide Circles</button>
            </div>
            <img id="main-image" src="kubesec-diagram.png" alt="Annotated Image" />
            <div id="tooltip-layer"></div>
        </div>
        <div id="debug-controls" style="display:none; gap: 6px; flex-direction: column; margin-top: 12px;">
            <label>
                X Multiplier: <input id="x-multiplier" type="number" step="0.001" value="1" style="width: 80px;" />
            </label>
            <label>
                Y Multiplier: <input id="y-multiplier" type="number" step="0.001" value="1" style="width: 80px;" />
            </label>
            <button id="export-coords" style="margin-top: 8px;">Export Adjusted Annotations</button>
        </div>
        <div id="annotation-list"></div>
    </div>

    <script>
        const debug = true;
        let xMultiplier = 1.0;
        let yMultiplier = 1.0;

        const config = {
            markerScale: 0.01,
            tooltipMinWidth: 320,
            typeStyles: {
                'pri-1': { bg: '#c00', color: '#fff', radius: '50%', border: 'orange' },
                'pri-2': { bg: '#f60', color: '#fff', radius: '50%', border: 'orange' },
                'pri-3': { bg: '#ff0', color: '#000', radius: '50%', border: 'orange' },
                'info': { bg: '#0af', color: '#fff', radius: '6px', border: '#004080' }
            }
        };

        const annotations = [
            { type: 'separator', title: 'Legend' },
            { type: 'pri-1', title: 'Pri-1', description: 'Focus on these first.' },
            { type: 'pri-2', title: 'Pri-2', description: 'Focus on these as well, but not that critical.' },
            { type: 'pri-3', title: 'Pri-3', description: 'Charrypick what you need, useful, but focus on others first' },
            { type: 'info', title: 'Additional info', description: 'Explainations for better understanding of a concept' },

            { type: 'separator', title: 'Security posibilities' },
            { x: 0.124, y: 0.040, type: 'pri-2', title: 'Git commits', description: 'Git commits can be signed by a physical key, like yubikey. This signature can be verifyed by ArgoCD.' },
            { x: 0.121, y: 0.220, type: 'pri-2', title: 'Service portal', description: 'For non-admins that want resources added to the cluster, it\'s common to have something in front of the "raw" kubectl command. It depends on your customer. You can setup a web-portal to "order" resources, something that add files to git, or anything in between. It should be separated from what the administrator uses, and have an additional layer of validation.' },
            { x: 0.911, y: 0.779, type: 'pri-2', title: 'Namespaced vs global resources', description: 'Most resources are namespace-scoped and require a namespace field. Some are cluster-wide, and others exist in both forms. Understanding this distinction is key to applying security policies correctly, whether cluster-wide or specific to app teams managing namespaces.' },
            { x: 0.792, y: 0.040, type: 'pri-2', title: 'Kubernetes distro/os\'es', description: 'There are many ways to install a kubernetes cluster. Do some research, and choose whats right for you. Maybe a full-blown OS that you need to patch in addition to kubernetes itself is not the best choice. There are dedicated and minimal kubernetes distroes that are hardened, immutable, minimal and dedicated to run kubernetes. If you are installing a cluster for production. It might be the best choice.' },
            { x: 0.565, y: 0.072, type: 'pri-2', title: 'Operators and infrastructure workload', description: 'This is a "typical" operator. It does something based on custom resource-types (here a Certificate). The operator controller in itself is nothing special in the cluster. It\'s just another (example) "Deployment" that has access to watch some custom kubernetes resources and act on it. The operator itself can run on a dedicated worker and the same rules applies to it as anything else.' },
            { x: 0.681, y: 0.253, type: 'pri-1', title: 'Namespaces', description: 'Namespaces do not provide security by themselves but serve as a foundation for enforcing it. Policies like network and runtime security often use namespaces as a boundary, allowing control over isolation, inter-namespace restrictions, or exceptions for privileged namespaces.\n\nNote that Kubernetes namespaces differ from process namespaces inside a container.' },
            { x: 0.608, y: 0.757, type: 'pri-1', title: 'The container process', description: 'The application process itself is heavely guarded using multiple enforcement mechanisms. The enforcements are defined in policies on the pod itself, the namespace, or using other controllers. Tools like Sysdig Secure uses eBPF to create rules on details what the processes and containers are doing. The container itself isn\'t awere of what rules applies to it.\n\nThere are many syscalls that are blocked inside the container as default.\nContainer escapes and 0-days (almost?) always requires badly configured capabilities, extra syscalls, custom security groups, custom mounts or tweaked kernel-namespace-settings.\n\nKernel namespaces make sure the process gets it\'s own set of pid\'s, network-interfaces and so on.\nCgroups enforces resource constraints for cpu, memory and more. It also has a freezer which in an instant can make sure the container won\'t get any more cpu cycles. Network sessions, memory info is all kept, but frozen. This is useful for inspection.\n\nContainers inside pods can also have a set of runtime policies that can make it easier to enforce certain policies like "dont run as root", "enforced UID" and so on. This is the behavior of the container that is often defined inside the Containerfile (build-file) of the container itself.\nNote! Some of the restrictions mentioned are defined on POD-level, some one container-level, and some can be defined on both.' },
            { x: 0.607, y: 0.340, type: 'pri-1', title: 'Ingress', description: 'The kubernetes Ingress type controls the ingress-controller which can be nginx, haproxy eller ligende. They can have additional annotations for special config, auth, mod_security and so on depending on the ingress-controller used.\n\nDestination is commonly based on SNI (FQDN and domainname). The traffic will get routed to the correct service based on typical L7 data, domainname, http-verb, etc..' },
            { x: 0.564, y: 0.364, type: 'pri-1', title: 'Default pod-to-pod traffic', description: 'Can be blocked using a default deny network policy rule.' },
            { x: 0.525, y: 0.369, type: 'pri-1', title: 'Network control', description: 'There are many ways of controlling policies internally in the network. L3 and L4 are usually enforced by eBPF or iptables rules on the system-level. L7 are normally enforced by a proxy of some sort.\n\nSome CNI\'s also supports administrative policies, where it will be owned by the cluster administrators and cant be overwritten. Useful to enforce cluster-wide or company policies.' },
            { x: 0.241, y: 0.685, type: 'pri-1', title: 'Image repository', description: 'Images in the image repository can be scanned before they are allowed to be stored.' },
            { x: 0.386, y: 0.063, type: 'pri-1', title: 'API', description: 'The Kubernetes API is very robust and have multiple enforcement points. Access to it is controlled by RBAC using verbs like CREATE, PATCH, DELETE, but also api-groups and resource-types. Behind it is etcd. Anonymous access is allowed by default. The API can give you very rich audit-logging, which you should enable and send to a remote logging service.' },
            { x: 0.375, y: 0.232, type: 'pri-2', title: 'Validating or mutating admission control', description: 'Example kyverno, which looks at the incomming yaml and validates it based on the context. This hook can also mutate the yaml to enforce certain configuration, like pod policy definitions or other configurations. Everything, including cluster-made resources needs to pass this.\n\nThere are also ways to validate image signatures and SLSA info here.' },
            { x: 0.342, y: 0.249, type: 'pri-2', title: 'API to etcd communication', description: 'Depending on the request, if it is a read operation or write, the api communication might differ.\nExample, if you do a GET-operation, you wont be able to use an admission-controller to intercept and control the permissions since the request would not hit the admission-controller.' },
            { x: 0.372, y: 0.335, type: 'pri-2', title: 'Secrets and configmaps', description: 'Can enter the cluster encrypted using descryption-keys available inside the cluster.' },
            { x: 0.315, y: 0.277, type: 'pri-2', title: 'A good CNI (like Cilium)', description: 'Should be used to block as much traffic as possible. This can be done as a baseline policy. Default network-policies might not be enough.' },
            { x: 0.595, y: 0.442, type: 'pri-2', title: 'Traffic before filters', description: 'This traffic can be encrypted using mTLS. It might not be possible to see the content of the traffic here. The traffic at this point contains a lot of metadata so it is possible to create ACL\'s based on context.' },
            { x: 0.392, y: 0.683, type: 'pri-2', title: 'Container image', description: 'Can be configured to only run signed images. Kyverno also supports an additional check here to enforce signature and properties from the container building itself. Images attached to a container can also be scanned for vulnerabilities and flagged.' },
            { x: 0.453, y: 0.677, type: 'pri-2', title: 'Mounted volumes and env-vars', description: 'Facts from outside the POD are normally exposed inside it as projected (read-only) volumes or environment variables. Data can also come in the for of dynamic variables from the pod-runtime (like pod-ip). If pod needs to talk to the cluster-api, the required token is mounted in as a service-user.' },
            { x: 0.541, y: 0.720, type: 'pri-2', title: 'Network interfaces', description: 'For special network requirements, there can be special network-interface types. All with different security aspects to keep in mind. Containers can bind directly to the host interface if you let them. You can also use interfaces like macvlan if you want your pod to be a first-class citizen on your network (useful for dhcp, multicast, vlans, ..). Using multus, you can even let the container have multiple interfaces.\n\nUnderlay methods will bypass network-policies, so be careful.\n\nOverlay networks (default) are what you get if you just use your CNI as normal.' },
            { x: 0.748, y: 0.922, type: 'pri-2', title: 'Internal pod egress', description: 'Traffic leaving a pod to another service inside the same cluster are subject to the same types of policies that can be applied to pod-ingress. It can be a separate set of rules.\nNormally, intracluster egress traffic might not be filtered as it\'s more common that the ingress  handles this. It is however possible.' },
            { x: 0.335, y: 0.882, type: 'pri-3', title: 'Egress', description: 'Egress will be defined by using pod labels and destinations. We can have a dedicated egress ip for a specific CIDR' },
            { x: 0.662, y: 0.778, type: 'pri-3', title: 'Custom container runtimes', description: 'There are some extra hardened container runtimes that can be configured. Example gVisor-containers comes with an additional layer of security by exposing a wrapped version of the kernel API. kata wrap around an additional virtualization layer around the container.\n\nThere are many other alternatives as well. In Openshift, it is called openshift sandbox and is based on kata.\n\nWASM is another type of application bundles/runtime that looks like will become the "next" wave of technology in cloud-native.' },
            { x: 0.650, y: 0.637, type: 'pri-3', title: 'Exposed port', description: 'Everything inside a single pod is in the same network-namespace and can only be on 1 single node. eBPF and mTLS can therefor be applied (and enforced) to a service without it even knowing. This allows us to handle the complexity of mTLS and filtering outside the application itself, making it perfectly secure (and prefeered) and fine to expose unencrypted port 80 from a pod.' },
            { x: 0.637, y: 0.598, type: 'pri-3', title: 'Traffic after filters', description: 'This traffic is the raw traffic the application receives. It is (at least in this case) not encrypted and can be inspected, before the traffic hits the proccess.' },
            { x: 0.449, y: 0.460, type: 'pri-3', title: 'VirtualMachine or other workload-types', description: 'There is nothing special with other types of workload. It will act as any other workloads and depend on the same mechanismes as the rest of the cluster.' },
            { x: 0.289, y: 0.487, type: 'pri-3', title: 'Other cluster nodes', description: 'This traffic can reach the other cluster using ip-to-ip (if configured) or encapsulated traffic. It can also be encrypted using a service-mesh.\n\nSome of the workloads should be pinned to special workers. It might be special applications that the cluster need, ingress-controllers, operators, AI workers, etc' },
            { x: 0.351, y: 0.282, type: 'pri-3', title: 'etcd', description: 'Can be encrypted at rest' },
            { x: 0.265, y: 0.251, type: 'pri-3', title: 'Cluster to cluster mesh (cluster-mesh)', description: 'If we have multiple cluster, we can have a cluster-mesh that gives us some of the cloud-native networking functionality. This traffic can be encrypted using mTLS as well with workload identities on each of the clusters. Using a cluster-mesh allows normal network-policies to work between clusters.' },
            { x: 0.274, y: 0.431, type: 'pri-3', title: 'Custom Operators / orchestrators', description: 'If you setup this pattern correctly, you can get some great security benefits because you can also leverage the other patterns that also comes with kubernetes.\n\nExample, if you want a custom "object" developers can add to the cluster to get a set of resources definied by your rules. Or even to create items outside the cluster.' },
            { x: 0.462, y: 0.102, type: 'pri-3', title: 'Internal API communication', description: 'API should only be exposed to internal operators and pods that needs to talk to the api. Should be blocked using network-policies as default' },
            { x: 0.469, y: 0.048, type: 'pri-3', title: 'Authentication webhook', description: 'Not that commonly used. But if you want additional security on top of RBAC, you can use authentication webhook to reject requests that doesnt comply. For example, deny request to namespaces matching a certain pattern.' },
            { x: 0.129, y: 0.415, type: 'pri-3', title: 'Service owner deployment', description: 'To add an additional layer of security, a dedicated git/argocd/flux stack for service owners that are deploying applications can be used. This argocd can be configured to only be allowed to change some resources on some namespaces.' },
            { x: 0.429, y: 0.185, type: 'pri-2', title: 'system:masters group', description: 'There is a group hardcoded in kubernetes that bypasses the authorization part of the API.\nThis should be used when bootstraping a user or if playing with global RBAC policies (example).\nElse, make sure there are noone in this group! It should not be used.' },

            { type: 'separator', title: 'Info' },
            { x: 0.545, y: 0.672, type: 'info', title: 'Multi-interface (Multus)', description: 'There can be more than one interface inside a single pod. Normally, this is done a CNI named Multus' },
            { x: 0.364, y: 0.423, type: 'info', title: 'A Deployment', description: 'This is the inside of 1 Deployment (same for DaemonSet, StatefulSet, ...). Deployments are shown as single objects in the rest of this diagram!' },
            { x: 0.231, y: 0.332, type: 'info', title: 'Whats an "operator"', description: '"Operators" in kubernetes can do a lot of work for you.\n\nLike the "System" object here creating some defaults and a Namespace.\nAn operator can also be used for resources outside the cluster, like here the "Tofu" object "owning" some infrastructure outside of the cluster.\n\nKubernetes doesnt need to run containers or workload to be a useful engine for other problem-spaces.' },
            { x: 0.900, y: 0.817, type: 'info', size: 'small', title: 'Configurable capability', description: 'Capability that can be configured and/or changed if needed.' },
            { x: 0.900, y: 0.769, type: 'info', size: 'small', title: 'Kubernetes resource', description: 'Kubernetes uses resource-types at it\'s core. Pod, Service, Deployment, Ingress, Node are all resource-types.\n\nSome of the resource-types in this diagram is made up. Most of them are optional just to show completness' },
        ];

        const image = document.getElementById('main-image');
        const wrapper = document.getElementById('image-wrapper');
        const tooltipLayer = document.getElementById('tooltip-layer');
        const container = document.getElementById('container');
        const list = document.getElementById('annotation-list');
        const toggleAnnBtn = document.getElementById('toggle-annotations');
        const toggleCirclesBtn = document.getElementById('toggle-markers');

        let markersRendered = false;

        function escapeHTML(str) {
            const div = document.createElement('div');
            div.innerText = str;
            return div.innerHTML;
        }

        function renderMarkers() {
            if (markersRendered) return;
            markersRendered = true;

            let priCounter = 1;
            let infoCounter = 1;

            annotations.forEach((ann) => {
                if (!ann.x || !ann.y || ann.type === 'hr') return;

                const style = config.typeStyles[ann.type] || { bg: '#ccc', color: '#000', radius: '50%', border: 'gray' };
                const isInfo = ann.type === 'info';
                const index = isInfo ? infoCounter++ : priCounter++;

                const wrapperEl = document.createElement('div');
                wrapperEl.style.position = 'absolute';
                wrapperEl.style.transform = 'translate(-50%, -50%)';
                wrapperEl.style.zIndex = '10';

                const marker = document.createElement('div');
                marker.className = 'marker';
                marker.setAttribute('data-index', index);
                marker.style.background = style.bg;
                marker.style.color = style.color;
                marker.style.borderRadius = style.radius;
                marker.style.borderColor = style.border;
                if (isInfo) marker.textContent = '?';

                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip-box';
                tooltip.innerHTML = `<b>${index}. ${escapeHTML(ann.title)}</b><br><br>${ann.description.replace(/\n/g, '<br>')}`;
                tooltip.style.display = 'none';
                tooltipLayer.appendChild(tooltip);

                let hideTimeout;

                wrapperEl.addEventListener('mouseenter', () => {
                    clearTimeout(hideTimeout);
                    const bounds = image.getBoundingClientRect();
                    const x = ann.x * bounds.width;
                    const y = ann.y * bounds.height;

                    tooltip.style.display = 'block';
                    tooltip.style.minWidth = config.tooltipMinWidth + 'px';

                    requestAnimationFrame(() => {
                        const tipWidth = tooltip.offsetWidth;
                        let adjustedX = x;

                        if (x - tipWidth / 2 < 0) {
                            adjustedX = tipWidth / 2;
                        } else if (x + tipWidth / 2 > bounds.width) {
                            adjustedX = bounds.width - tipWidth / 2;
                        }

                        tooltip.style.left = `${adjustedX}px`;
                        tooltip.style.top = `${y + 1}px`;
                    });
                });

                wrapperEl.addEventListener('mouseleave', () => {
                    hideTimeout = setTimeout(() => tooltip.style.display = 'none', 100);
                });

                tooltip.addEventListener('mouseenter', () => {
                    clearTimeout(hideTimeout);
                });

                tooltip.addEventListener('mouseleave', () => {
                    hideTimeout = setTimeout(() => tooltip.style.display = 'none', 100);
                });

                wrapperEl.appendChild(marker);
                wrapper.appendChild(wrapperEl);

                ann._el = wrapperEl;
                ann._tooltip = tooltip;
                ann._index = index;
            });

            positionMarkers();
        }

        function positionMarkers() {
            const bounds = image.getBoundingClientRect();

            annotations.forEach(ann => {
                if (!ann._el) return;

                const scale = config.markerScale;
                const factor = ann.size === 'small' ? 0.5 : 1.0;
                const size = bounds.width * scale * factor;

                const wrapperEl = ann._el;
                const marker = wrapperEl.querySelector('.marker');

                const left = ann.x * bounds.width * xMultiplier;
                const top = ann.y * bounds.height * yMultiplier;

                wrapperEl.style.left = `${left}px`;
                wrapperEl.style.top = `${top}px`;

                marker.style.width = `${size}px`;
                marker.style.height = `${size}px`;
                marker.style.fontSize = `${size * 0.5}px`;
            });
        }

        function renderList() {
            list.innerHTML = '';
            let priCounter = 1;
            let infoCounter = 1;

            annotations.forEach((ann) => {
                if (ann.type === 'separator') {
                    const sep = document.createElement('div');
                    sep.className = 'annotation-separator';
                    sep.innerHTML = `<span>${escapeHTML(ann.title || '')}</span>`;
                    list.appendChild(sep);
                    return;
                }

                if (!('x' in ann) || !('y' in ann)) {
                    const item = document.createElement('div');
                    item.className = 'annotation-item';
                    const style = config.typeStyles[ann.type] || { bg: '#ccc', color: '#000' };
                    item.innerHTML = `
        <div style="display: flex; align-items: flex-start; gap: 6px;">
            <div style="background:${style.bg};color:${style.color};padding:2px 6px;border-radius:4px;white-space:nowrap;">-</div>
            <div>
                <b>${escapeHTML(ann.title)}</b><br>${ann.description.replace(/\n/g, '<br>')}
            </div>
        </div>`;
                    list.appendChild(item);
                    return;
                }

                const style = config.typeStyles[ann.type] || { bg: '#ccc', color: '#000' };
                const isInfo = ann.type === 'info';
                const index = isInfo ? infoCounter++ : priCounter++;

                const item = document.createElement('div');
                item.className = 'annotation-item';
                item.innerHTML = `
        <div style="display: flex; align-items: flex-start; gap: 6px;">
            <div style="background:${style.bg};color:${style.color};padding:2px 6px;border-radius:4px;white-space:nowrap;">
                ${index}
            </div>
            <div>
                <b>${escapeHTML(ann.title)}</b><br>${ann.description.replace(/\n/g, '<br>')}
            </div>
        </div>`;
                list.appendChild(item);
            });
        }

        // move listeners and event bindings outside of renderList()
        toggleAnnBtn.addEventListener('click', () => {
            const showing = list.classList.toggle('visible');
            container.classList.toggle('numbered', showing);
            document.body.classList.toggle('annotations-active', showing);
            if (showing) {
                renderList();
                toggleAnnBtn.textContent = 'Hide Annotations';
                if (container.classList.contains('hidden-markers')) {
                    container.classList.remove('hidden-markers');
                    toggleCirclesBtn.textContent = 'Hide Circles';
                }
                positionMarkers(); // 👈 legg til denne
            } else {
                list.innerHTML = '';
                toggleAnnBtn.textContent = 'Show Annotations';
                positionMarkers(); // 👈 legg til denne også
            }
        });

        toggleCirclesBtn.addEventListener('click', () => {
            const nowHidden = container.classList.toggle('hidden-markers');
            toggleCirclesBtn.textContent = nowHidden ? 'Show Circles' : 'Hide Circles';
            if (nowHidden) {
                list.innerHTML = '';
                toggleAnnBtn.textContent = 'Show Annotations';
                list.classList.remove('visible');
            }
        });

        image.addEventListener('load', () => {
            renderMarkers();
            positionMarkers();

            if (debug) {
                document.getElementById('debug-controls').style.display = 'flex';
            }
        });

        window.addEventListener('resize', positionMarkers);

        if (debug) {
            image.addEventListener('click', e => {
                const rect = image.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = (e.clientY - rect.top) / rect.height;
                console.log(`{ x: ${x.toFixed(3)}, y: ${y.toFixed(3)}, type: 'pri-3', title: 'Title', description: 'Description' },`);
            });

            document.getElementById('debug-controls').style.display = 'flex';

            const xInput = document.getElementById('x-multiplier');
            const yInput = document.getElementById('y-multiplier');
            const exportBtn = document.getElementById('export-coords');

            xInput.addEventListener('input', () => {
                xMultiplier = parseFloat(xInput.value) || 1;
                positionMarkers();
            });

            yInput.addEventListener('input', () => {
                yMultiplier = parseFloat(yInput.value) || 1;
                positionMarkers();
            });

            exportBtn.addEventListener('click', () => {
                const updated = annotations.map(a => {
                    const clean = Object.fromEntries(
                        Object.entries(a).filter(([key, _]) => !key.startsWith('_'))
                    );

                    if ('x' in clean && 'y' in clean) {
                        clean.x = parseFloat((clean.x * xMultiplier).toFixed(4));
                        clean.y = parseFloat((clean.y * yMultiplier).toFixed(4));
                    }

                    return clean;
                });

                console.log(updated);
            });
        }
    </script>
</body>

</html>
